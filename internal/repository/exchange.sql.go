// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: exchange.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const ArchiveRate = `-- name: ArchiveRate :exec
insert into general.history_rates(currency_from, currency_to, created_at, rate) 
(select cur.currency_from, cur.currency_to, cur.updated_at, cur.rate from general.current_rates as cur where cur.currency_from = $1 AND cur.currency_to = $2)
ON CONFLICT (currency_from, currency_to, created_at) DO NOTHING
`

type ArchiveRateParams struct {
	CurrencyFrom string `db:"currency_from" json:"currency_from"`
	CurrencyTo   string `db:"currency_to" json:"currency_to"`
}

func (q *Queries) ArchiveRate(ctx context.Context, arg ArchiveRateParams) error {
	_, err := q.db.Exec(ctx, ArchiveRate, arg.CurrencyFrom, arg.CurrencyTo)
	return err
}

const GetCuurentRate = `-- name: GetCuurentRate :one
select currency_from, currency_to, rate from general.current_rates where currency_from = $1 AND currency_to = $2
`

type GetCuurentRateParams struct {
	CurrencyFrom string `db:"currency_from" json:"currency_from"`
	CurrencyTo   string `db:"currency_to" json:"currency_to"`
}

type GetCuurentRateRow struct {
	CurrencyFrom string         `db:"currency_from" json:"currency_from"`
	CurrencyTo   string         `db:"currency_to" json:"currency_to"`
	Rate         pgtype.Numeric `db:"rate" json:"rate"`
}

func (q *Queries) GetCuurentRate(ctx context.Context, arg GetCuurentRateParams) (*GetCuurentRateRow, error) {
	row := q.db.QueryRow(ctx, GetCuurentRate, arg.CurrencyFrom, arg.CurrencyTo)
	var i GetCuurentRateRow
	err := row.Scan(&i.CurrencyFrom, &i.CurrencyTo, &i.Rate)
	return &i, err
}

const GetRateOnDate = `-- name: GetRateOnDate :one
select hr1.currency_from, hr1.currency_to, hr1.rate from general.history_rates as hr1
where hr1.currency_from = $1 
AND hr1.currency_to = $2 
AND hr1.created_at = (
    select max(hr.created_at) from general.history_rates as hr
    where hr.currency_from = $1 
    AND hr.currency_to = $2 
    AND hr.created_at < $3 
    order by hr.currency_from asc, hr.currency_to asc, hr.rate asc
    )
`

type GetRateOnDateParams struct {
	CurrencyFrom string             `db:"currency_from" json:"currency_from"`
	CurrencyTo   string             `db:"currency_to" json:"currency_to"`
	CreatedAt    pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

type GetRateOnDateRow struct {
	CurrencyFrom string         `db:"currency_from" json:"currency_from"`
	CurrencyTo   string         `db:"currency_to" json:"currency_to"`
	Rate         pgtype.Numeric `db:"rate" json:"rate"`
}

func (q *Queries) GetRateOnDate(ctx context.Context, arg GetRateOnDateParams) (*GetRateOnDateRow, error) {
	row := q.db.QueryRow(ctx, GetRateOnDate, arg.CurrencyFrom, arg.CurrencyTo, arg.CreatedAt)
	var i GetRateOnDateRow
	err := row.Scan(&i.CurrencyFrom, &i.CurrencyTo, &i.Rate)
	return &i, err
}

const UpdateRate = `-- name: UpdateRate :exec
insert into general.current_rates (currency_from, currency_to, rate, updated_at) 
values ($1, $2, $3, now())
on conflict (currency_from, currency_to) do update 
    set rate = EXCLUDED.rate, updated_at=EXCLUDED.updated_at
    where current_rates.rate != EXCLUDED.rate
`

type UpdateRateParams struct {
	CurrencyFrom string         `db:"currency_from" json:"currency_from"`
	CurrencyTo   string         `db:"currency_to" json:"currency_to"`
	Rate         pgtype.Numeric `db:"rate" json:"rate"`
}

func (q *Queries) UpdateRate(ctx context.Context, arg UpdateRateParams) error {
	_, err := q.db.Exec(ctx, UpdateRate, arg.CurrencyFrom, arg.CurrencyTo, arg.Rate)
	return err
}
